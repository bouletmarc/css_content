// This is the base rule script file for the AI response system for Expressive AI's who speak based on certain "Concepts"
// You can think of a concept as a high level state that the code is trying to convey, such as say hello, or say you're mad, etc.
//
// The format of this file is that there are five main types of commands:
// 1) #include "filename"	// This just causes the included scriptfile to be parsed and added to the database
// 2) enumeration:  this declares an enumerated type so that comparisons can be matched against the string versions of the type
// 3) response:  this specifies a response to issue.  A response consists of a weighted set of options and can recursively reference
//    other responses by name
// 4) criterion:  This is a match condition
// 5) rule:  a rule consists of one or more criteria and a response
//
// In general, the system is presented with a criteria set, which is a set of key value pairs generated by the game code and
//  various entity I/O and keyfields.  For instance, the following criteria set was created in a map with a train terminal 
// "speaker" entity wishing to fire random station announcements
//               concept = 'train_speaker' (weight 5.000000)		; the high level concept for the search request
//                   map = 'terminal_pa'							; the name of the map
//             classname = 'speaker'								; the classname and name of the "speaking" entity
//                  name = 'terminal_pa'
//                health = '10'										; the absolute health of the speaking entity
//            healthfrac = '0.000'									; the health fraction (health/maxhealth) of the speaking entity
//          playerhealth = '100'									; similar data related to the current player:
//      playerhealthfrac = '1.000'
//          playerweapon = 'none'									; the name of the weapon the player is carrying
//        playeractivity = 'ACT_WALK'								; animating activity of the player
//           playerspeed = '0.000'									; how fast the player is moving
//
// Based on such a criteria set, the system checks each rule against the set.  To do this, each criterion of the rule is
//  given a numeric score as follows:
// score = 0 if criteria doesn't match or, criterion weight * keyvaliue weight if it does match
// The final score for a rule is the sum of all of the scores of its criteria.  The best rule is the one with the highest
//  score.  Once a best rule is selected, then a response is looked up based on the response definitions and the engine is
//  asked to dispatch that response.
//
// The specific syntax for the various keywords is as follows:
//
// ENUMERATIONS:
//
// enumeration <enumerationname>
// { 
//		"key1" "value1"
//		"key2" "value2"
//		...etc.
//	}
//	The code and criteria refer to enumerations with square brackets and a double colon separator, e.g.:
//  [enumerationname::key1]
//
//
// RESPONSES:
//
// Single line: 
// response <responsegroupname> [nodelay | defaultdelay | delay interval ] [speakonce] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] responsetype parameters
// Multiple lines
// response <responsegroupname>
// {
//		[permitrepeats]   ; optional parameter, by default we visit all responses in group before repeating any
//		[sequential]	  ; optional parameter, by default we randomly choose responses, but with this we walk through the list starting at the first and going to the last
//		[norepeat]		  ; Once we've run through all of the entries, disable the response group
//		responsetype1 parameters1 [nodelay | defaultdelay | delay interval ] [speakonce] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] [displayfirst] [ displaylast ] weight nnn
//		responsetype2 parameters2 [nodelay | defaultdelay | delay interval ] [speakonce] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] [displayfirst] [ displaylast ] weight nnn
//		etc.
// }
// Where: 
//   interval = "startnumber,endnumber" or "number" (e.g., "2.8,3.2" or "3.2")
//   responsetype =:
//     speak		; it's an entry in sounds.txt
//     sentence		; it's a sentence name from sentences.txt
//     scene		; it's a .vcd file
//     response		; it's a reference to another response group by name
//   nodelay = an additional delay of 0 after speaking
//   defaultdelay = an additional delay of 2.8 to 3.2 seconds after speaking
//   delay interval = an additional delay based on a random sample from the interval after speaking
//   speakonce = don't use this response more than one time (default off)
//   odds = if this response is selected, if odds < 100, then there is a chance that nothing will be said (default 100)
//	 respeakdelay = don't use this response again for at least this long (default 0)
//   soundlevel = use this soundlevel for the speak/sentence (default SNDLVL_TALKING)
//   weight = if there are multiple responses, this is a selection weighting so that certain responses are favored over others in the group (default 1)
//   displayfirst/displaylast : this should be the first/last item selected (ignores weight)
//
// CRITERIA:
//
// criterion <criterionname> <matchkey> <matchvalue> weight nnn required
// Where:
//  matchkey matches one of the criteria in the set as shown above
//  matchvalue is a string or number value or a range, the following are all valid:
//  "0"						; numeric match to value 0
//  "1"						; numeric match to value 1
//   "weapon_smg1"			; string match to weapon_smg1 string
//   "[npcstate::idle]"		; match enumeration by looking up numeric value
//   ">0"					; match if greater than zero
//   ">10,<=50"				; match if greater than ten and less than or equal to 50
//   ">0,<[npcstate::alert]"	; match if greater than zer and les then value of enumeration for alert
//   "!=0"					; match if not equal to zero
// weight = floating point weighting for score assuming criteria match (default value 1.0)
// required:  if a rule has one or more criteria with the required flag set, then if any such criteria
//  fail, the entire rule receives a score of zero
//
// RULE:
//
// rule <rulename>
// {
//    criteria name1 [name2 name3 etc.]
//    response responsegroupname [responsegroupname2 etc.]
//    [matchonce]					; optional parameter
//	  [ <matchkey > <matchvalue> weight nnn required ]
// }
// Where:
// criteria just lies one more more criterion names from above and response list one or more of the response
// names from above (usually just one)
// matchonce (off by default): means that the rule is deactivated after the first time it is matched
// Note that additional "unnamed" criteria can be specified inline in the rule using the same syntax
// as for defining a criterion, except for the criterion keyword and the criterion name keys
//
// Interaction with entity I/O system
// CBaseEntity contains an inputfunc called "DispatchResponse" which accepts a string which is a concept name
//  Thus, a game entity can fire this input on another entity with a concept string and a criteria set will
//  be generated and searched against the entities current response system rule set.
// Right now only the speaker entity and NPC_Talker derived NPCs have any response rules loaded
// In addition, map placed entities have up to three "context" keypairs that can be specified.
// They take the form:  "key:value" (key, single colon separator, value)
// When an entity with any such context keypairs is asked to dispatch a response, the keypairs are added to the
//  criteria set passed to the rule system.  Thus, map placed entities and triggers can specify their
//  own context keypairs and these can be hooked up to response rules to do map-specific and appropriate
//  responses
// In addition, entity I/O can be used to add, remove and clear any such context keypairs via the
//   AddContext, RemoveContext, and ClearContext input functions.
// AddContext takes a keypair of the "key:value" format, while RemoveContext take just the "key"
// ClearContext removes all context keypairs
// The game .dll code can enumerate context keypairs and change them via code based methods
//
// The player and the world have their context added with the string player or world as a prefix, e.g.:
//  "playerkey:value" or "worldkey:value" to differentiate world/player context from the context of the
//  responding entity.

// Base script
enumeration "NPCState"
{
	"None"		"0"
	"Idle"		"1"
	"Alert"		"2"
	"Combat"	"3"
	"Scripted"	"4"
	"PlayDead"	"5"
	"Dead"		"6"
}

response "NullResponse"

criterion "ConceptTalkAnswer" "Concept" "TLK_ANSWER" required weight 1
criterion "ConceptTalkQuestion" "Concept" "TLK_QUESTION" required // weight 1 implied
criterion "ConceptTalkIdle" "Concept" "TLK_IDLE" required
criterion "ConceptTalkStare" "Concept" "TLK_STARE" required
criterion "ConceptTalkUse" "Concept" "TLK_USE" required
criterion "ConceptTalkUnuse" "Concept" "TLK_UNUSE" required
criterion "ConceptTalkStop" "Concept" "TLK_STOP" required
criterion "ConceptTalkNoShoot" "Concept" "TLK_NOSHOOT" required
criterion "ConceptTalkHello" "Concept" "TLK_HELLO" required
criterion "ConceptTalkPHello" "Concept" "TLK_PHELLO" required
criterion "ConceptTalkPIdle" "Concept" "TLK_PIDLE" required
criterion "ConceptTalkPQuestion" "Concept" "TLK_PQUESTION" required
criterion "ConceptTalkPlayerHurt1" "Concept" "TLK_PLHURT1" required
criterion "ConceptTalkPlayerHurt2" "Concept" "TLK_PLHURT2" required
criterion "ConceptTalkPlayerHurt3" "Concept" "TLK_PLHURT3" required
criterion "ConceptTalkSmell" "Concept" "TLK_SMELL" required
criterion "ConceptTalkWound" "Concept" "TLK_WOUND" required
criterion "ConceptTalkMortal" "Concept" "TLK_MORTAL" required
criterion "ConceptTalkDanger" "Concept" "TLK_DANGER" required
criterion "ConceptTalkResume" "Concept" "TLK_RESUME" required
criterion "ConceptTalkHeal" "Concept" "TLK_HEAL" required
criterion "ConceptTalkTourGuideStayPut" "Concept" "TLK_TGSTAYPUT" required
criterion "ConceptTalkTourGuideFind" "Concept" "TLK_TGFIND" required
criterion "ConceptTalkTourGuideSeek" "Concept" "TLK_TGSEEK" required
criterion "ConceptTalkTourGuideLostYou" "Concept" "TLK_TGLOSTYOU" required
criterion "ConceptTalkTourGuideCatchUp" "Concept" "TLK_TGCATCHUP" required
criterion "ConceptTalkTourGuideEndTour" "Concept" "TLK_TGENDTOUR" required
criterion "ConceptTalkSelected" "Concept" "TLK_SELECTED" required
criterion "ConceptTalkCommanded" "Concept" "TLK_COMMANDED" required
criterion "ConceptTalkCommandFailed" "Concept" "TLK_COMMAND_FAILED" required
criterion "ConceptTalkBetrayed" "Concept" "TLK_BETRAYED" required
criterion "ConceptTalkGiveAmmo" "Concept" "TLK_AMMO" required
criterion "ConceptTalkAllyKilled" "Concept" "TLK_ALLY_KILLED" required
criterion "ConceptSeeCombine" "Concept" "TLK_SEE_COMBINE" required
criterion "ConceptEnemyDead" "Concept" "TLK_ENEMY_DEAD" required
criterion "ConceptTalkWatchOut" "Concept" "TLK_WATCHOUT" required
criterion "ConceptTalkAttacking" "Concept" "TLK_ATTACKING" required
criterion "ConceptTalkDeath" "Concept" "TLK_DEATH" required
criterion "ConceptTalkHelpMe" "Concept" "TLK_HELP_ME" required

// Lead behavior
criterion "ConceptLeadStart" "Concept" "TLK_LEAD_START" required			// Spoken once when the NPC first starts to lead the player
criterion "ConceptLeadWaitOver" "Concept" "TLK_LEAD_WAITOVER" required			// Spoken when the player arrives at an NPC waiting to lead the player
criterion "ConceptLeadAttractPlayer" "Concept" "TLK_LEAD_ATTRACTPLAYER" required	// Nag spoken by a NPC waiting to lead the player, trying to attract the player
criterion "ConceptLeadCatchup" "Concept" "TLK_LEAD_CATCHUP" required			// Spoken by the NPC when the player's lagging behind
criterion "ConceptLeadComingBack" "Concept" "TLK_LEAD_COMINGBACK" required		// Spoken when the NPC comes back to find a lost player
criterion "ConceptLeadRetrieve" "Concept" "TLK_LEAD_RETRIEVE" required			// Spoken when the NPC has come back to the player, and is now resuming the lead
criterion "ConceptLeadArrival" "Concept" "TLK_LEAD_ARRIVAL" required			// Spoken when the leading NPC reaches the target point
criterion "ConceptLeadSuccess" "Concept" "TLK_LEAD_SUCCESS" required			// Spoken when the player and the leading NPC have both reached the target point
criterion "ConceptLeadMissingWeapon" "Concept" "TLK_LEAD_MISSING_WEAPON" required	// Spoken when the NPC refuses to lead the player because he's missing a weapon

// Citizen responses
criterion "ConceptCRPlayerShotGunship" "Concept" "TLK_CITIZEN_RESPONSE_SHOT_GUNSHIP" required
criterion "ConceptCRPlayerKilledGunship" "Concept" "TLK_CITIZEN_RESPONSE_KILLEd_GUNSHIP" required
criterion "ConceptCRVitalNPCDied" "Concept" "TLK_VITALNPC_DIED" required

criterion "PlayerAlive" "PlayerHealth" ">0" required
criterion "PlayerDead" "PlayerHealth" "<=0" required
criterion "PlayerWounded" "PlayerHealthFrac"	">0,<=.5"
criterion "NPCAlive" "Health" ">0" required
criterion "NPCAlert" "NPCState" ">=[NPCState::Idle],<[NPCState::Alert]"
criterion "NPCIdle" "NPCState" "[NPCState::Idle]" required


// Kelly, if you ever read this, here is the simple version:
//
// First you make a rule. Say the code is sending the string "Pain" to the script.
// You want a rule that says, "concept MUST be 'Pain'" so we make a criterion ( single criteria )
// like this:
//
// criterion "IsPainConcept"  "concept"  "Pain"	"required"
//
// This just means that whenever we say "criteria IsPainConcept", we really mean is the concept 
// equal to the string "Pain"
// 
// When we make a rule, that gets applied to every response thats sent to the script, so if we want
// one that just makes pain noises, we include IsPainConcept on the criteria line. If we wanted to make
// a light damage pain and a heavy damage pain, you would do this:
//
// have one rule with:
// criteria IsPainConcept "Health" ">50"		- this rule will 'win' if we want to make pain AND we have more than 50 health
// 
// and another one with
// criteria IsPainConcept "Health" "<=50"		- this rule will 'win' if we want to make pain AND we have less than 50 health
//
// then inside the rule we call a response, which is just a list of the sounds that we might want to make.
// we might also include scenes in here at a future time.

//================
// CRITERIA
//================
criterion "NotRescued"				"rescued"	"no"			"required"
criterion "IsBlindFromFlashbang"	"flashed"	"yes"			"required"
criterion "IsNotBlindFromFlashbang"	"flashed"	"no"			"required"
criterion "IsInSmokeConcept"		"concept"	"InSmoke"		"required"
criterion "IsSeeGrenadeConcept"	"concept"	"SeeGrenade"	"required"
criterion "IsSeeRescueZoneConcept"	"concept"	"SeeRescueZone"	"required"
criterion "IsRescuedConcept"		"concept"	"Rescued"		"required"
criterion "IsFlashbangedConcept"	"concept"	"Flashbanged"	"required"
criterion "IsCTWinConcept"		"concept"	"CTWin"			"required"
criterion "IsTWinConcept"		"concept"	"TWin"			"required"
criterion "IsPainConcept" 		"concept"	"Pain" 			"required"
criterion "IsDeathConcept"		"concept"	"Death"			"required"	//<-- implement me
criterion "IsStartFollowingConcept"	"concept"	"StartFollowing" "required"
criterion "IsStopFollowingConcept"	"concept"   "StopFollowing"	"required"
criterion "IsFollowingT"		"leaderteam"    "T"			"required"
criterion "IsFollowingCT"		"leaderteam"	"CT"		"required"
criterion "IsGreetCTConcept" 		"concept"	"GreetCT" 		"required"
criterion "IsGreetTConcept" 		"concept"	"GreetT" 		"required"
criterion "IsDmgReactionConcept"	"concept"	"DmgReaction"	"required"


//================
// RESPONSES
//================

response DmgReactionResponse
{
	speak "Hostage.DamageReaction1"	odds 10
	speak "Hostage.DamageReaction2"	odds 10
	speak "Hostage.DamageReaction3"	odds 10
	speak "Hostage.DamageReaction4"	odds 10
	speak "Hostage.DamageReaction5"	odds 10
	speak "Hostage.DamageReaction6"	odds 10
	speak "Hostage.DamageReaction7"	odds 10
	speak "Hostage.DamageReaction8"	odds 10
	speak "Hostage.DamageReaction9"	odds 10
	speak "Hostage.DamageReaction10"	odds 10
	speak "Hostage.DamageReaction11"	odds 10
	speak "Hostage.DamageReaction12"	odds 10
	speak "Hostage.DamageReaction13"	odds 10
}

response InSmokeResponse
{
	speak "Hostage.Cough1"	odds 50
	speak "Hostage.Cough2"	odds 50
	speak "Hostage.Cough3"	odds 50
	speak "Hostage.Cough4"	odds 50
	speak "Hostage.Cough5"	odds 50
	speak "Hostage.Cough6"	odds 50
}

response SeeGrenadeResponse
{
	speak "Hostage.SeeGren1"	odds 30
	speak "Hostage.SeeGren2"	odds 30
	speak "Hostage.Run"	odds 30
	speak "Hostage.WatchOut"	odds 30
}

response RescuedResponse
{
	speak "Hostage.Rescued"
}

response SeeRescueZoneResponse
{
	speak "Hostage.SeeRescueZone1" 
	speak "Hostage.SeeRescueZone2" 
	speak "Hostage.SeeRescueZone3" 
	speak "Hostage.SeeRescueZone4" 
	speak "Hostage.SeeRescueZone5" 
}

response "FlashbangedResponse"
{
	speak	"Hostage.Flashbang1"	odds 65
	speak	"Hostage.Flashbang2"	odds 65
}

response "CTWinResponse"
{
	speak	"Hostage.CTWin1"	odds 30
	speak	"Hostage.CTWin2"	odds 30
	speak	"Hostage.CTWin3"	odds 30
	speak	"Hostage.CTWin4"	odds 30
	speak	"Hostage.CTWin5"	odds 30
	speak	"Hostage.CTWin6"	odds 30
	speak	"Hostage.CTWin7"	odds 30
	speak	"Hostage.CTWin8"	odds 30
	speak	"Hostage.CTWin9"	odds 30
}

response "TWinResponse"
{
	speak	"Hostage.TWin1"	odds 30
	speak	"Hostage.TWin2"	odds 30
	speak	"Hostage.TWin3"	odds 30
	speak	"Hostage.TWin4"	odds 30
	speak	"Hostage.TWin5"	odds 30
}

response "GreetTResponse"
{
	speak	"Hostage.TGreeting"
}

response "GreetCTResponse"
{
	speak	"Hostage.CTGreeting"
}

response "PainResponse"
{
	speak	"Hostage.Pain"	delay 1.5	//don't say anything for another 1.5 seconds
}

response "StartFollowingCTResponse"
{
	speak "Hostage.StartFollowCT"
}

response "StopFollowingCTResponse"
{
	speak "Hostage.StopFollowCT"
}

response "StartFollowingTResponse"
{
	speak "Hostage.StartFollowT1"
	speak "Hostage.StartFollowT2"
	speak "Hostage.StartFollowT3"
	speak "Hostage.StartFollowT4"
	speak "Hostage.StartFollowT5"
	speak "Hostage.StartFollowT6"
	speak "Hostage.StartFollowT7"
}

response "StopFollowingTResponse"
{
	speak "Hostage.StartFollowT1"	//use the same wavs
	speak "Hostage.StartFollowT2"
	speak "Hostage.StartFollowT3"
	speak "Hostage.StartFollowT4"
	speak "Hostage.StartFollowT5"
	speak "Hostage.StartFollowT6"
	speak "Hostage.StartFollowT7"
}



//================
// RULES
//================


//----------------------
// Misc rules
//----------------------

rule DmgReactionResponse
{
	criteria IsDmgReactionConcept NotRescued	//WasNotJustInjured ?
	response DmgReactionResponse
}

rule InSmokeResponse
{
	criteria IsInSmokeConcept NotRescued
	response InSmokeResponse
}

rule SeeGrenadeResponse
{
	criteria IsSeeGrenadeConcept IsNotBlindFromFlashbang NotRescued
	response SeeGrenadeResponse
}

rule RescuedResponse
{
	criteria    IsRescuedConcept
	response	RescuedResponse
}

rule SeeRescueZoneResponse
{
	criteria	IsSeeRescueZoneConcept
	response	SeeRescueZoneResponse
}

rule FlashbangedResponse
{
	criteria IsFlashbangedConcept NotRescued
	response FlashbangedResponse
}

rule PainResponse
{
	criteria	IsPainConcept NotRescued
	response	PainResponse
}



//----------------------
//Start / Stop Following
//----------------------

rule StartFollowingCTResponse
{
	criteria	IsFollowingCT IsStartFollowingConcept
	response    StartFollowingCTResponse
}

rule StopFollowingCTResponse
{
	criteria	IsFollowingCT IsStopFollowingConcept
	response    StopFollowingCTResponse
}

rule StartFollowingTResponse
{
	criteria	IsFollowingT IsStartFollowingConcept
	response    StartFollowingTResponse
}

rule StopFollowingTResponse
{
	criteria	IsFollowingT IsStopFollowingConcept
	response    StopFollowingTResponse
}



//----------------------
// Greetings
//----------------------

rule GreetTResponse
{
	criteria		IsGreetTConcept NotRescued
	response		GreetTResponse
}

rule GreetCTResponse
{
	criteria		IsGreetCTConcept NotRescued
	response		GreetCTResponse
}


//----------------------
// Win responses
//----------------------

rule CTWinResponse
{
	criteria IsCTWinConcept NotRescued
	response CTWinResponse
}

rule TWinResponse
{
	criteria IsTWinConcept NotRescued
	response TWinResponse
}
































